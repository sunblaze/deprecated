# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `avro` gem.
# Please instead update this file by running `bin/tapioca gem avro`.

module Avro
  class << self
    def disable_enum_symbol_validation; end
    def disable_enum_symbol_validation=(_arg0); end
    def disable_field_default_validation; end
    def disable_field_default_validation=(_arg0); end
    def disable_schema_name_validation; end
    def disable_schema_name_validation=(_arg0); end
  end
end

class Avro::AvroError < ::StandardError; end

class Avro::AvroTypeError < ::Avro::AvroError
  def initialize(schm = T.unsafe(nil), datum = T.unsafe(nil), msg = T.unsafe(nil)); end
end

module Avro::DataFile
  class << self
    def codecs; end
    def get_codec(codec); end
    def open(file_path, mode = T.unsafe(nil), schema = T.unsafe(nil), codec = T.unsafe(nil)); end
    def register_codec(codec); end

    private

    def open_reader(file, schema); end
    def open_writer(file, schema, codec = T.unsafe(nil)); end
  end
end

class Avro::DataFile::DataFileError < ::Avro::AvroError; end

class Avro::DataFile::DeflateCodec
  def initialize(level = T.unsafe(nil)); end

  def codec_name; end
  def compress(data); end
  def decompress(compressed); end
  def level; end
end

Avro::DataFile::MAGIC = T.let(T.unsafe(nil), String)
Avro::DataFile::MAGIC_SIZE = T.let(T.unsafe(nil), Integer)
Avro::DataFile::META_SCHEMA = T.let(T.unsafe(nil), Avro::Schema::MapSchema)

class Avro::DataFile::NullCodec
  def codec_name; end
  def compress(data); end
  def decompress(data); end
end

class Avro::DataFile::Reader
  include ::Enumerable

  def initialize(reader, datum_reader); end

  def block_count; end
  def block_count=(_arg0); end
  def block_decoder; end
  def close; end
  def codec; end
  def datum_reader; end
  def decoder; end
  def each; end
  def eof?; end
  def file_length; end
  def meta; end
  def reader; end
  def sync_marker; end

  private

  def read_block_header; end
  def read_header; end
  def skip_sync; end
end

Avro::DataFile::SYNC_INTERVAL = T.let(T.unsafe(nil), Integer)
Avro::DataFile::SYNC_SIZE = T.let(T.unsafe(nil), Integer)

class Avro::DataFile::SnappyCodec
  def codec_name; end
  def compress(data); end
  def decompress(data); end

  private

  def load_snappy!; end
end

Avro::DataFile::VALID_CODECS = T.let(T.unsafe(nil), Array)
Avro::DataFile::VALID_ENCODINGS = T.let(T.unsafe(nil), Array)
Avro::DataFile::VERSION = T.let(T.unsafe(nil), Integer)

class Avro::DataFile::Writer
  def initialize(writer, datum_writer, writers_schema = T.unsafe(nil), codec = T.unsafe(nil), meta = T.unsafe(nil)); end

  def <<(datum); end
  def block_count; end
  def block_count=(_arg0); end
  def buffer_encoder; end
  def buffer_writer; end
  def close; end
  def codec; end
  def datum_writer; end
  def encoder; end
  def flush; end
  def meta; end
  def sync; end
  def sync_marker; end
  def writer; end

  private

  def write_block; end
  def write_header; end

  class << self
    def generate_sync_marker; end
  end
end

class Avro::DataFile::ZstandardCodec
  def codec_name; end
  def compress(data); end
  def decompress(data); end

  private

  def load_zstandard!; end
end

module Avro::IO; end

class Avro::IO::AvroTypeError < ::Avro::AvroError
  def initialize(expected_schema, datum); end
end

class Avro::IO::BinaryDecoder
  def initialize(reader); end

  def byte!; end
  def read(len); end
  def read_boolean; end
  def read_bytes; end
  def read_double; end
  def read_float; end
  def read_int; end
  def read_long; end
  def read_null; end
  def read_string; end
  def reader; end
  def skip(n); end
  def skip_boolean; end
  def skip_bytes; end
  def skip_double; end
  def skip_float; end
  def skip_int; end
  def skip_long; end
  def skip_null; end
  def skip_string; end

  private

  def read_and_unpack(byte_count, format); end
end

class Avro::IO::BinaryEncoder
  def initialize(writer); end

  def write(datum); end
  def write_boolean(datum); end
  def write_bytes(datum); end
  def write_double(datum); end
  def write_float(datum); end
  def write_int(n); end
  def write_long(n); end
  def write_null(_datum); end
  def write_string(datum); end
  def writer; end
end

class Avro::IO::DatumReader
  def initialize(writers_schema = T.unsafe(nil), readers_schema = T.unsafe(nil)); end

  def read(decoder); end
  def read_array(writers_schema, readers_schema, decoder); end
  def read_data(writers_schema, readers_schema, decoder); end
  def read_default_value(field_schema, default_value); end
  def read_enum(writers_schema, readers_schema, decoder); end
  def read_fixed(writers_schema, _readers_schema, decoder); end
  def read_map(writers_schema, readers_schema, decoder); end
  def read_record(writers_schema, readers_schema, decoder); end
  def read_union(writers_schema, readers_schema, decoder); end
  def readers_schema; end
  def readers_schema=(_arg0); end
  def skip_array(writers_schema, decoder); end
  def skip_data(writers_schema, decoder); end
  def skip_enum(_writers_schema, decoder); end
  def skip_fixed(writers_schema, decoder); end
  def skip_map(writers_schema, decoder); end
  def skip_record(writers_schema, decoder); end
  def skip_union(writers_schema, decoder); end
  def writers_schema; end
  def writers_schema=(_arg0); end

  private

  def skip_blocks(decoder, &blk); end

  class << self
    def match_schemas(writers_schema, readers_schema); end
  end
end

class Avro::IO::DatumWriter
  def initialize(writers_schema = T.unsafe(nil)); end

  def write(datum, encoder); end
  def write_array(writers_schema, datum, encoder); end
  def write_data(writers_schema, logical_datum, encoder); end
  def write_enum(writers_schema, datum, encoder); end
  def write_fixed(_writers_schema, datum, encoder); end
  def write_map(writers_schema, datum, encoder); end
  def write_record(writers_schema, datum, encoder); end
  def write_union(writers_schema, datum, encoder); end
  def writers_schema; end
  def writers_schema=(_arg0); end
end

Avro::IO::DatumWriter::VALIDATION_OPTIONS = T.let(T.unsafe(nil), Hash)

class Avro::IO::SchemaMatchException < ::Avro::AvroError
  def initialize(writers_schema, readers_schema); end
end

module Avro::IPC; end
class Avro::IPC::AvroRemoteError < ::Avro::AvroError; end
class Avro::IPC::AvroRemoteException < ::Avro::AvroError; end
Avro::IPC::BUFFER_HEADER_LENGTH = T.let(T.unsafe(nil), Integer)
Avro::IPC::BUFFER_SIZE = T.let(T.unsafe(nil), Integer)
class Avro::IPC::ConnectionClosedError < ::StandardError; end
class Avro::IPC::ConnectionClosedException < ::Avro::AvroError; end

class Avro::IPC::FramedReader
  def initialize(reader); end

  def read_framed_message; end
  def reader; end

  private

  def chunk_error?(chunk); end
  def read_buffer_size; end
end

class Avro::IPC::FramedWriter
  def initialize(writer); end

  def to_s; end
  def write_framed_message(message); end
  def writer; end

  private

  def write_buffer(chunk); end
  def write_buffer_size(n); end
end

Avro::IPC::HANDSHAKE_REQUESTOR_READER = T.let(T.unsafe(nil), Avro::IO::DatumReader)
Avro::IPC::HANDSHAKE_REQUESTOR_WRITER = T.let(T.unsafe(nil), Avro::IO::DatumWriter)
Avro::IPC::HANDSHAKE_REQUEST_SCHEMA = T.let(T.unsafe(nil), Avro::Schema::RecordSchema)
Avro::IPC::HANDSHAKE_RESPONDER_READER = T.let(T.unsafe(nil), Avro::IO::DatumReader)
Avro::IPC::HANDSHAKE_RESPONDER_WRITER = T.let(T.unsafe(nil), Avro::IO::DatumWriter)
Avro::IPC::HANDSHAKE_RESPONSE_SCHEMA = T.let(T.unsafe(nil), Avro::Schema::RecordSchema)

class Avro::IPC::HTTPTransceiver
  def initialize(host, port); end

  def host; end
  def port; end
  def remote_name; end
  def transceive(message); end
end

Avro::IPC::META_READER = T.let(T.unsafe(nil), Avro::IO::DatumReader)
Avro::IPC::META_SCHEMA = T.let(T.unsafe(nil), Avro::Schema::MapSchema)
Avro::IPC::META_WRITER = T.let(T.unsafe(nil), Avro::IO::DatumWriter)
Avro::IPC::REMOTE_HASHES = T.let(T.unsafe(nil), Hash)
Avro::IPC::REMOTE_PROTOCOLS = T.let(T.unsafe(nil), Hash)

class Avro::IPC::Requestor
  def initialize(local_protocol, transport); end

  def local_protocol; end
  def read_call_response(message_name, decoder); end
  def read_error(writers_schema, readers_schema, decoder); end
  def read_handshake_response(decoder); end
  def read_response(writers_schema, readers_schema, decoder); end
  def remote_hash; end
  def remote_hash=(new_remote_hash); end
  def remote_protocol; end
  def remote_protocol=(new_remote_protocol); end
  def request(message_name, request_datum); end
  def send_protocol; end
  def send_protocol=(_arg0); end
  def transport; end
  def write_call_request(message_name, request_datum, encoder); end
  def write_handshake_request(encoder); end
  def write_request(request_schema, request_datum, encoder); end
end

class Avro::IPC::Responder
  def initialize(local_protocol); end

  def call(_local_message, _request); end
  def local_hash; end
  def local_protocol; end
  def process_handshake(decoder, encoder, connection = T.unsafe(nil)); end
  def protocol_cache; end
  def read_request(writers_schema, readers_schema, decoder); end
  def respond(call_request, transport = T.unsafe(nil)); end
  def write_error(writers_schema, error_exception, encoder); end
  def write_response(writers_schema, response_datum, encoder); end
end

Avro::IPC::SYSTEM_ERROR_SCHEMA = T.let(T.unsafe(nil), Avro::Schema::UnionSchema)

class Avro::IPC::SocketTransport
  def initialize(sock); end

  def close; end
  def is_connected?; end
  def protocol; end
  def protocol=(_arg0); end
  def read_buffer_length; end
  def read_framed_message; end
  def remote_name; end
  def sock; end
  def transceive(request); end
  def write_buffer(chunk); end
  def write_buffer_length(n); end
  def write_framed_message(message); end
end

module Avro::LogicalTypes
  class << self
    def type_adapter(type, logical_type); end
  end
end

module Avro::LogicalTypes::Identity
  class << self
    def decode(datum); end
    def encode(datum); end
  end
end

module Avro::LogicalTypes::IntDate
  class << self
    def decode(int); end
    def encode(date); end
  end
end

Avro::LogicalTypes::IntDate::EPOCH_START = T.let(T.unsafe(nil), Date)
Avro::LogicalTypes::TYPES = T.let(T.unsafe(nil), Hash)

module Avro::LogicalTypes::TimestampMicros
  class << self
    def decode(int); end
    def encode(value); end
  end
end

module Avro::LogicalTypes::TimestampMillis
  class << self
    def decode(int); end
    def encode(value); end
  end
end

module Avro::Name
  class << self
    def add_name(names, new_schema); end
    def extract_namespace(name, namespace); end
    def make_fullname(name, namespace); end
  end
end

class Avro::Protocol
  def initialize(name, namespace = T.unsafe(nil), types = T.unsafe(nil), messages = T.unsafe(nil), doc = T.unsafe(nil)); end

  def ==(other); end
  def doc; end
  def md5; end
  def messages; end
  def name; end
  def namespace; end
  def to_s; end
  def types; end

  protected

  def to_avro(names = T.unsafe(nil)); end

  private

  def parse_messages(messages, names); end
  def parse_types(types, type_names); end

  class << self
    def parse(protocol_string); end
  end
end

class Avro::Protocol::Message
  def initialize(name, request, response, errors = T.unsafe(nil), names = T.unsafe(nil), default_namespace = T.unsafe(nil), doc = T.unsafe(nil)); end

  def default_namespace; end
  def doc; end
  def errors; end
  def name; end
  def parse_errors(errors, names); end
  def parse_request(request, names); end
  def parse_response(response, names); end
  def request; end
  def response; end
  def to_avro(names = T.unsafe(nil)); end
  def to_s; end
end

class Avro::Protocol::ProtocolParseError < ::Avro::AvroError; end
Avro::Protocol::VALID_TYPE_SCHEMA_TYPES = T.let(T.unsafe(nil), Set)
Avro::Protocol::VALID_TYPE_SCHEMA_TYPES_SYM = T.let(T.unsafe(nil), Set)

class Avro::Schema
  def initialize(type, logical_type = T.unsafe(nil)); end

  def ==(other, _seen = T.unsafe(nil)); end
  def be_read?(other_schema); end
  def crc_64_avro_fingerprint; end
  def hash(_seen = T.unsafe(nil)); end
  def initFPTable; end
  def logical_type; end
  def md5_fingerprint; end
  def mutual_read?(other_schema); end
  def read?(writers_schema); end
  def sha256_fingerprint; end
  def single_object_encoding_header; end
  def single_object_schema_fingerprint; end
  def subparse(json_obj, names = T.unsafe(nil), namespace = T.unsafe(nil)); end
  def to_avro(_names = T.unsafe(nil)); end
  def to_s; end
  def type; end
  def type_adapter; end
  def type_sym; end

  private

  def validate_aliases!; end

  class << self
    def parse(json_string); end
    def real_parse(json_obj, names = T.unsafe(nil), default_namespace = T.unsafe(nil)); end
    def validate(expected_schema, logical_datum, options = T.unsafe(nil)); end
  end
end

class Avro::Schema::ArraySchema < ::Avro::Schema
  def initialize(items, names = T.unsafe(nil), default_namespace = T.unsafe(nil)); end

  def items; end
  def to_avro(names = T.unsafe(nil)); end
end

Avro::Schema::Bignum = Integer

class Avro::Schema::BytesSchema < ::Avro::Schema::PrimitiveSchema
  def initialize(type, logical_type = T.unsafe(nil), precision = T.unsafe(nil), scale = T.unsafe(nil)); end

  def precision; end
  def scale; end
  def to_avro(names = T.unsafe(nil)); end
end

Avro::Schema::CRC_EMPTY = T.let(T.unsafe(nil), Integer)
Avro::Schema::DEFAULT_VALIDATE_OPTIONS = T.let(T.unsafe(nil), Hash)

class Avro::Schema::EnumSchema < ::Avro::Schema::NamedSchema
  def initialize(name, space, symbols, names = T.unsafe(nil), doc = T.unsafe(nil), default = T.unsafe(nil), aliases = T.unsafe(nil)); end

  def default; end
  def doc; end
  def symbols; end
  def to_avro(_names = T.unsafe(nil)); end
end

Avro::Schema::EnumSchema::SYMBOL_REGEX = T.let(T.unsafe(nil), Regexp)

class Avro::Schema::Field < ::Avro::Schema
  def initialize(type, name, default = T.unsafe(nil), order = T.unsafe(nil), names = T.unsafe(nil), namespace = T.unsafe(nil), doc = T.unsafe(nil), aliases = T.unsafe(nil)); end

  def alias_names; end
  def aliases; end
  def default; end
  def default?; end
  def doc; end
  def name; end
  def order; end
  def to_avro(names = T.unsafe(nil)); end
  def type; end

  private

  def validate_default!; end
end

class Avro::Schema::FixedSchema < ::Avro::Schema::NamedSchema
  def initialize(name, space, size, names = T.unsafe(nil), logical_type = T.unsafe(nil), aliases = T.unsafe(nil)); end

  def size; end
  def to_avro(names = T.unsafe(nil)); end
end

Avro::Schema::Fixnum = Integer
Avro::Schema::INT_MAX_VALUE = T.let(T.unsafe(nil), Integer)
Avro::Schema::INT_MIN_VALUE = T.let(T.unsafe(nil), Integer)
Avro::Schema::LONG_MAX_VALUE = T.let(T.unsafe(nil), Integer)
Avro::Schema::LONG_MIN_VALUE = T.let(T.unsafe(nil), Integer)

class Avro::Schema::MapSchema < ::Avro::Schema
  def initialize(values, names = T.unsafe(nil), default_namespace = T.unsafe(nil)); end

  def to_avro(names = T.unsafe(nil)); end
  def values; end
end

Avro::Schema::NAMED_TYPES = T.let(T.unsafe(nil), Set)
Avro::Schema::NAMED_TYPES_SYM = T.let(T.unsafe(nil), Set)
Avro::Schema::NAME_REGEX = T.let(T.unsafe(nil), Regexp)

class Avro::Schema::NamedSchema < ::Avro::Schema
  def initialize(type, name, namespace = T.unsafe(nil), names = T.unsafe(nil), doc = T.unsafe(nil), logical_type = T.unsafe(nil), aliases = T.unsafe(nil)); end

  def aliases; end
  def fullname; end
  def fullname_aliases; end
  def match_fullname?(name); end
  def name; end
  def namespace; end
  def to_avro(names = T.unsafe(nil)); end
end

Avro::Schema::PRIMITIVE_TYPES = T.let(T.unsafe(nil), Set)
Avro::Schema::PRIMITIVE_TYPES_SYM = T.let(T.unsafe(nil), Set)

class Avro::Schema::PrimitiveSchema < ::Avro::Schema
  def initialize(type, logical_type = T.unsafe(nil)); end

  def to_avro(names = T.unsafe(nil)); end
end

class Avro::Schema::RecordSchema < ::Avro::Schema::NamedSchema
  def initialize(name, namespace, fields, names = T.unsafe(nil), schema_type = T.unsafe(nil), doc = T.unsafe(nil), aliases = T.unsafe(nil)); end

  def doc; end
  def fields; end
  def fields_by_alias; end
  def fields_hash; end
  def to_avro(names = T.unsafe(nil)); end

  class << self
    def make_field_objects(field_data, names, namespace = T.unsafe(nil)); end
  end
end

Avro::Schema::SINGLE_OBJECT_MAGIC_NUMBER = T.let(T.unsafe(nil), Array)

class Avro::Schema::UnionSchema < ::Avro::Schema
  def initialize(schemas, names = T.unsafe(nil), default_namespace = T.unsafe(nil)); end

  def schemas; end
  def to_avro(names = T.unsafe(nil)); end
end

Avro::Schema::VALID_TYPES = T.let(T.unsafe(nil), Set)
Avro::Schema::VALID_TYPES_SYM = T.let(T.unsafe(nil), Set)

module Avro::SchemaCompatibility
  class << self
    def can_read?(writers_schema, readers_schema); end
    def match_schemas(writers_schema, readers_schema); end
    def mutual_read?(writers_schema, readers_schema); end
  end
end

class Avro::SchemaCompatibility::Checker
  def initialize; end

  def can_read?(writers_schema, readers_schema); end
  def mutual_read?(writers_schema, readers_schema); end

  private

  def full_match_schemas(writers_schema, readers_schema); end
  def match_record_schemas(writers_schema, readers_schema); end
  def match_union_schemas(writers_schema, readers_schema); end
  def recursion_in_progress?(writers_schema, readers_schema); end
  def recursion_set; end
end

Avro::SchemaCompatibility::Checker::SIMPLE_CHECKS = T.let(T.unsafe(nil), Set)
Avro::SchemaCompatibility::INT_COERCIBLE_TYPES_SYM = T.let(T.unsafe(nil), Array)
Avro::SchemaCompatibility::LONG_COERCIBLE_TYPES_SYM = T.let(T.unsafe(nil), Array)

class Avro::SchemaNormalization
  def initialize; end

  def to_parsing_form(schema); end

  private

  def normalize_field(field); end
  def normalize_named_type(schema, attributes = T.unsafe(nil)); end
  def normalize_schema(schema); end

  class << self
    def to_parsing_form(schema); end
  end
end

class Avro::SchemaParseError < ::Avro::AvroError; end

class Avro::SchemaValidator
  class << self
    def validate!(expected_schema, logical_datum, options = T.unsafe(nil)); end

    private

    def actual_value_message(value); end
    def deeper_path_for_hash(sub_key, path); end
    def enum_message(symbols, datum); end
    def first_compatible_type(datum, expected_schema, path, failures, options = T.unsafe(nil)); end
    def fixed_string_message(size, datum); end
    def resolve_datum(expected_schema, logical_datum, encoded); end
    def ruby_integer_to_avro_type(value); end
    def ruby_to_avro_type(ruby_class); end
    def validate_array(expected_schema, datum, path, result, options); end
    def validate_map(expected_schema, datum, path, result, options); end
    def validate_recursive(expected_schema, logical_datum, path, result, options); end
    def validate_simple(expected_schema, logical_datum, path, result, options); end
    def validate_type(expected_schema); end
    def validate_union(expected_schema, datum, path, result, options); end
  end
end

Avro::SchemaValidator::BOOLEAN_VALUES = T.let(T.unsafe(nil), Array)
Avro::SchemaValidator::COMPLEX_TYPES = T.let(T.unsafe(nil), Array)
Avro::SchemaValidator::DEFAULT_VALIDATION_OPTIONS = T.let(T.unsafe(nil), Hash)
Avro::SchemaValidator::INT_RANGE = T.let(T.unsafe(nil), Range)
Avro::SchemaValidator::LONG_RANGE = T.let(T.unsafe(nil), Range)
Avro::SchemaValidator::PATH_SEPARATOR = T.let(T.unsafe(nil), String)
Avro::SchemaValidator::RECURSIVE_SIMPLE_VALIDATION_OPTIONS = T.let(T.unsafe(nil), Hash)
Avro::SchemaValidator::ROOT_IDENTIFIER = T.let(T.unsafe(nil), String)
Avro::SchemaValidator::RUBY_CLASS_TO_AVRO_TYPE = T.let(T.unsafe(nil), Hash)

class Avro::SchemaValidator::Result
  def <<(error); end
  def add_error(path, message); end
  def errors; end
  def failure?; end
  def to_s; end
end

class Avro::SchemaValidator::TypeMismatchError < ::Avro::SchemaValidator::ValidationError; end

class Avro::SchemaValidator::ValidationError < ::StandardError
  def initialize(result = T.unsafe(nil)); end

  def result; end
  def to_s; end
end

class Avro::UnknownSchemaError < ::Avro::SchemaParseError
  def initialize(type); end

  def type_name; end
end

Avro::VERSION = T.let(T.unsafe(nil), String)
